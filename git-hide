#!/usr/bin/env python

from __future__ import print_function

import os
import sys
import re

import argparse
from subprocess import call

#def make_branches_dir():
#    try:
#        os.makedirs('.git/refsbranches')
#    except OSError:
#        pass


def get_branch_name(branch):
    return '.git/refs/heads/{}'.format(branch)

def get_hidden_name(branch):
    return '.git/refs/hidden/{}'.format(branch)


def archive_branch(branch):

    if not os.path.exists(get_branch_name(branch)):
        print("Branch {} does not exist".format(branch))
        return

    # Don't archive an existing branch
    if os.path.exists(get_hidden_name(branch)):
        print("Hidden branch: {} already exists".format(branch))
        return

    make_archive = "git update-ref refs/hidden/{0} {0}".format(branch)
    res = call(make_archive, shell=True)
    if res != 0:
        return

    delete_branch = "git branch -D {}".format(branch)
    res = call(delete_branch, shell=True)
    if res != 0:
        return


def restore_branch(branch):
    source = get_hidden_name(branch)
    destination = get_branch_name(branch)
    os.rename(source, destination)


def main():

    parser = argparse.ArgumentParser(description='Process some integers.')

    parser.add_argument('-b', '--branch', help='Branch to archive')

    parser.add_argument('-r', '--restore', help='Restore a hidden branch')

    args = parser.parse_args()

    if args.branch:
        archive_branch(args.branch)

    if args.restore:
        restore_branch(args.restore)


if __name__ == '__main__':
    main()
